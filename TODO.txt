!!! GUARDA COSA FA CADIAPLAYER CON ZHADU --> PER CASO SPOSTA ALLA FINE DEL GOAL LE DISTINCT? O SI IMPALLA? Funziona se uso =/= ????

check amazons torus








v - TEST PROPNET CONSISTENCY VS PROVER
- REFACTOR PROPNET STATE MACHINE CODE (REMOVE THE BUILDING TIME LIMITATION AND ADD IT TO AN EXTERNAL WRAPPING STATE MACHINE)
- CHECK IN THE PROPNET STATE MACHINE IF ROLES ARE COMPUTED LIKE THIS: "roles = ImmutableList.copyOf(Role.computeRoles(description));"
- RE-TEST REFACTORED PROPNET CONSISTENCY VS PROVER
- COMPARE PROPNET SPEED (NODES/SEC) WITH PROPNET+CASH (AND THEN WITH PROVER)
- SET UP YAP PROVER ON WINDOWS
V - SET UP YAP PROVER ON SERVER
V - TEST YAP PROVER CONSISTENCY VS PROVER
- REFACTOR YAP STATE MACHINE CODE TO BE MORE MODULAR (!!!!!!!!! PROBLEM!: if there is no solution for a goal Inerprolog returns null as binding => nullPointerException is thrown when casting the element at position[0] of the bindings --> FIX THIS! MOREOVER: change the query to get the goal because atm it assumes that the goal always exists and it's only one! But not alway is true...find a way to get back all(if any) the goals and check if there is only one or if an exception has to be thrown! --> Same thing to check for other methods (i.e. what happens if there is nothing true in the next state?, what happens if there are no legal moves???????? MOREOVER: if initialization fails the current state (i.e. the one that should keep track of prolog state) of the state machine is null => whatever method is called next will throw a nullpointerexception when checking if it's the case to update the prolog state or not!))
- RE-TEST REFACTORED YAP PROVER CONSISTENCY VS PROVER
- PLAY WITH GDLFactory CLASS TO SEE IF IT'S USEFUL TO TRANSLATE FROM STRING TO GDL (DOES IT INCREASE OR DECREASE SPEED?)
- MODIFY REFACTORED YAP PROVER CODE TO IMPROVE IT (E.G. YAPRenderer = GDLRenderer e YAPScrambler = MAppingGDLScrambler, check if it's faster with scrambling or without scrambling(without scrambling is it faster to use the renderer anyway or better gdl.toString) WHEN CHANGING PROLOG STATE: check if it's faster to retract and assert all facts on prolog or assert and retract only the diffs computed with java (i.e. prolog.retract(setDiff(currentState, nextState)), prolog.assert(setDiff(nextState, current state))))) --- tolgo dall'insieme di proposizioni che danno lo stato corrente le proposizioni che sono anche nell'insieme dello stato futuro e retraggo da prolog quelle rimanenti, poi tolgo dallo stato futuro le proposizioni che sono anche nello stato corrente e asserisco in prolog quelle rimanenti.
- MAKE ALL PATH SPECIFICATIONS IN THE CODE PLATFORM-INDEPENDENT (e.g. USING FILE.SEPARATOR IN THE CLASS "FILE")
- COMPARE YAP SPEED (NODES/SEC) WITH PROVER SPEED
- COMPARE YAP SPEED (NODES/SEC) WITH PROPNET SPEED?
- FIX THE COMMENTS FOR OVERRIDDEN METHODS IN PROPNET TO (NON-JAVADOC) COMMENTS (RICORDA CHE BASTA APRIRE IL COMMENTO CON /* E POI ANDARE A CAPO PER AVERE IL (NON-JAVADOC))
(E.G. 	/* (non-Javadoc)
	 * @see org.ggp.base.util.statemachine.StateMachine#getGoal(org.ggp.base.util.statemachine.MachineState, org.ggp.base.util.statemachine.Role)
	 */
)
- FIX GAMER LOGGER LOGS (WHEN TO USE LOG, LOGERROR OR LOGSTACKTRACE?, CHECK THAT ALL EXCEPTION/ERRORS HAVE A LOGGGED MESSAGE, CHECK ALL CALLS TO GAMERLOGGER)
- ADD LOGS FOR CSV IN GAMER LOGGER
- WRITE CODE TO SET UP AND RUN EXPERIMENTS
- SET UP VISUALIZATION OF CSV STATISTICS
- CREATE HYBRID PROVER (HOW? IS IT BETTER TO CALL THE PROVER IF YAP FAILS OR FIRST RESET YAP AND TRY AGAIN TO ASK IT?)
- IMPROVE PROPNET IMPLEMENTING WHOLE PLAYOUT IN STATE MACHINE AND IMPLEMENTING METHODS SUCH THAT TRANSLATIONS FROM PROPNET STATE TO MACHINESTATE ARE REDUCED
- IMPROVE PROPNET WITH SUGGESTIONS FROM SANCHO'S BLOG OR FROM ITS CODE
- IMPROVE YAP PROVER (E.G. RETURN PROLOG TERMS INSTEAD OF TRANSLATING THEM FIRST TO STRINGS ON PROLOG SIDE)
- WHAT INFLUENCES PROPNET CONSTRUCTION SPEED? SOMETIMES IT BUILDS SLOW AND SOME TIMES FAST FOR SOME GAMES! --> FIND OUT WHY!
- FIX EXCEPTION LOGGING: 1. FOR EACH EXCEPTION THAT IS THROWN, ADD THE MESSAGE THAT EXPLAINS THE EXCEPTION (throw new Exception("Explanation message!")) AND LOG THAT EXCEPTION HAS BEEN THROWN 2. FOR EACH EXCEPTION THAT IS THROWN BECAUSE OF ANOTHER EXCEPTION THAT HAS BEEN CAUGHT, ADD BOTH THE MESSAGE AND THE CAUSE (throw new Exception("Explanation message!", causeException)) 3. FOR EACH CAUGHT EXCEPTION (THAT WON'T CAUSE ANOTHER EXCEPTION TO BE THROWN), LOG THE PERSONAL ERROR MESSAGE (GamerLogger.logError("Personal mex")) AND THEN THE STACK TRACE (GamerLogger.logStackTrace()). SEE http://www.avajava.com/tutorials/lessons/how-do-i-chain-exceptions.html?page=1 FOR EXAMPLES ON THROWING CHAINED EXCEPTIONS.


FIX YAP:
- rename all variables in the description with _lowercaseLetter instead of UPPERCASELETTER (i.e. A --> _a)
- PROBLEM!: if there is no solution for a goal Inerprolog returns null as binding => nullPointerException is thrown when casting the element at position[0] of the bindings --> FIX THIS!
- MOREOVER: change the query to get the goal because atm it assumes that the goal always exists and it's only one! But not alway is true...find a way to get back all(if any) the goals and check if there is only one or if an exception has to be thrown! --> Same thing to check for other methods (i.e. what happens if there is nothing true in the next state?, what happens if there are no legal moves???????? - MOREOVER: if initialization fails the current state (i.e. the one that should keep track of prolog state) of the state machine is null => whatever method is called next will throw a nullpointerexception when checking if it's the case to update the prolog state or not!
- RETURN PROLOG TERMS INSTEAD OF TRANSLATING THEM FIRST TO STRINGS ON PROLOG SIDE
- FOR YAP STATE MACHINE USE AN EXTENSION OF MACHINESTATE THAT CAN CONVERT FROM NORMAL STATE TO PROLOG STATE?
- CHECK IF IT'S FASTER TO TRANSLATE FROM GDL TO PROLOG SYNTAX USING A METHOD IN EACH GDL TERM CLASS LIKE toPrologSyntax()
- CHECK IF IT'S FASTER WITH OR WITHOUT SCRAMBLING
- CHECK HOW THE YAP STATE MACHINE COULD BE MADE FASTER (I.E. DIFFERENT STATE REPRESENTATION THAT DOESN'T NEED TRANSLATION => THE GAMER TAHT KNOWS THAT IT IS USING YAP STATE MACHINE MUST KNOW HOW TO DEAL WITH DIFFERENT STATE FORMAT + A MECHANISM IS NEEDED TO CONVERT FROM YAP STATE TO GGPBASE STATE WHEN STRICTLY NECESSARY (AND THIS WILL STILL SLOW DOWN PERFORMANCE A BIT))
- AFTER REFACTORING TEST IF GT_TOW_THIRDS... GIVES ERROR FOR THE DEFINITION OF SUCC (FIX IT!)
- ADD TO THE CODE THAT PARSES (AND OPTIONALLY SCRAMBLES) GDL INTO PROLOG A WAY TO CHECK IF A CONSTANT IN GDL HAS THE SAME NAME OF A PROLOG PREDICATE AND THUS MUST BE CHANGED (USE (*))
- CHECK IF RECORD PREDICATES HALP MAKING YAP FASTER (YAP DOCUMENTATION 6.11)







(*)FROM YAP DOCUMENTATION 6.10.2
 listing
Lists in the current output stream all the clauses for which source code is available (these include all clauses for dynamic predicates and clauses for static predicates compiled when source mode was on).

listing(+P)
Lists predicate P if its source code is available.

portray_clause(+C)
Write clause C as if written by listing/0.

portray_clause(+S,+C)
Write clause C on stream S as if written by listing/0.

current_atom(A)
Checks whether A is a currently defined atom. It is used to find all currently defined atoms by backtracking.

current_predicate(F) [ISO]
F is the predicate indicator for a currently defined user or library predicate. F is of the form Na/Ar, where the atom Na is the name of the predicate, and Ar its arity.

current_predicate(A,P)
Defines the relation: P is a currently defined predicate whose name is the atom A.

system_predicate(A,P)
Defines the relation: P is a built-in predicate whose name is the atom A.

predicate_property(P,Prop) [ISO]
For the predicates obeying the specification P unify Prop with a property of P. These properties may be:

built_in
true for built-in predicates,

dynamic
true if the predicate is dynamic

static
true if the predicate is static

meta_predicate(M)
true if the predicate has a meta_predicate declaration M.

multifile
true if the predicate was declared to be multifile

imported_from(Mod)
true if the predicate was imported from module Mod.

exported
true if the predicate is exported in the current module.

public
true if the predicate is public; note that all dynamic predicates are public.

tabled
true if the predicate is tabled; note that only static predicates can be tabled in YAP.

source
true if source for the predicate is available.

number_of_clauses(ClauseCount)
Number of clauses in the predicate definition. Always one if external or built-in. 








- LOGGING FOR EACH PLAYER (log4j2) -> ALSO TO SAVE STATISTICS IN MACHINE READABLE FORMAT -> Switch routing with StructuredDataMEssage to routing with Markers
- GRAPHICAL VISUALIZATION OF STATISTICS
- COMPARE SINGLE PLAYER USING GAMER LOGGER WITH SINGLE PLAYER USING LO4J2 (COMPARE SPEED (NODES/S) -> COMPARE FOR ALL PROVERS??)
- SET EXPERIMENTS -> CONFIGURATION OF GAMERS + CONFIGURATION OF MATCHES
- PROPNET STATE MACHINE
- GAME SERVER LOGGING
- MCTS PARALLELIZATION
- USE PROXY PLAYER (DON'T SEND BACK ONLY FINAL MOVE CHOICE, BUT ALSO INTERMEDIATE MOVE CHOICES USING THE "NOTIFY OBSERVERS" METHOD FROM THE GAMER WITH A "WORKING RESPONSE SELECTED EVENT" INSTEAD OF "GAMER SELECTED MOVE EVENT")

- (ADAPTIVE TIMEOUT CHECK) when checking for timeout: since 1 smulation can take more than 10 seconds, for the first iteration check the timeout inside the iteration. Once you have a first value as indicator of the time that one iteration takes, modify the check for timeouts accordingly. (es: if the first iteration times out, checking during iteration allows the player to send a random move in time (or the most reasonable move if there is another way to compute it). if the iteration takes 1 second the you can check for timeout after 8-9 iterations (for example))
- ridurre in controllo del timeout (una volta ogni ? iterazioni invece che dopo ogni iterazione)
- Aggiungere un limite alla profonditá del playout per assicurare che ogni simulazione termini anche nel caso di un gioco illimitato (i.e. il game tree ha dei cammini infiniti) NB: GGP games terminano sempre => non ci sono cicli nel grafo. NB2: un GDL game puó essere rappresentato piú concisamente da un DAG (directed acyclic graph)
- Aggiungere controllo globale del timeout (controllo durante le simulazioni se ho raggiunto il timeout)
- Leggi paper e guarda codice Torsten
- Implementare MCS e MCTS
- Implementare propnet + capire codice state machine
- Guardare come CADIAPLAYER gestisce timeout
- Guardare come CADIAPLAYER gestisce YAP
- Testare i player su giochi classici per GGP (othello, checkers,...)
- Re-implementare minmax e alpha-beta unificando maxscore e minscore
- Papers da leggere per GGP:
	* Simultaneous move games (matrix representation) - Chiedere titolo!
	* Libro GGP di Genesereth
	* Efficient Grounding of Game Descriptions with Tabling (Computer Games 504)
	* Cazenave - Combining nested MCS with UCT
- Guaradre materiale corso Intelligent Search & Games

PROPNET:

- implementare metodi state machine su propnet
- migliorare traduzione da GDL a PROPNET (eliminare nodi ridondanti, refactor della propnet per diminuire dimensioni, ecc... - fare i TODO elencati in GGP per lóttimizzazione della propnet)
- migliorare struttura dati (occupare meno spazio, fare meno operazioni e velocizzare il procedimento sia di traduzione sia di reasoning)


a state is defined by the perviously defined propositions. When all propositions except does are given a truth value, the game state is completely defined and can be used to reason on it. When, after reasoning, the truth value of the does propositions is assigned, it is possible to compute the next state (where all propositions will have atruth value except the does proposition)